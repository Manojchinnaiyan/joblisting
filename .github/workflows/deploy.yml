name: Deploy to Production

on:
  push:
    branches: [main, master]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io

jobs:
  # Set lowercase repo name
  setup:
    name: Setup
    runs-on: ubuntu-latest
    outputs:
      backend_image: ${{ steps.set-images.outputs.backend_image }}
      frontend_image: ${{ steps.set-images.outputs.frontend_image }}
    steps:
      - name: Set lowercase image names
        id: set-images
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "backend_image=ghcr.io/${REPO_LOWER}/backend" >> $GITHUB_OUTPUT
          echo "frontend_image=ghcr.io/${REPO_LOWER}/frontend" >> $GITHUB_OUTPUT

  # Run tests first
  test-backend:
    name: Test Backend
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: backend

    services:
      postgres:
        image: postgres:17-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: jobdb_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7.4-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache-dependency-path: backend/go.sum

      - name: Download dependencies
        run: go mod download

      - name: Run tests
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: postgres
          DB_PASSWORD: postgres
          DB_NAME: jobdb_test
          DB_SSLMODE: disable
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          JWT_SECRET: test-jwt-secret-for-ci
          APP_ENV: test
        run: go test -v -race ./...

      - name: Build check
        run: go build -v ./...

  test-frontend:
    name: Test Frontend
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: frontend

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'
          cache-dependency-path: frontend/yarn.lock

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Lint
        run: yarn lint

      - name: Type check
        run: yarn type-check

      - name: Build
        env:
          NEXT_PUBLIC_API_URL: http://localhost:8080/api/v1
        run: yarn build

  # Build and push Docker images
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: [setup, test-backend, test-frontend]
    permissions:
      contents: read
      packages: write
    outputs:
      backend_image: ${{ needs.setup.outputs.backend_image }}
      frontend_image: ${{ needs.setup.outputs.frontend_image }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ needs.setup.outputs.backend_image }}
          tags: |
            type=sha,prefix=
            type=raw,value=latest

      - name: Build and push Backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Extract metadata for Frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ needs.setup.outputs.frontend_image }}
          tags: |
            type=sha,prefix=
            type=raw,value=latest

      - name: Build and push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}

  # Deploy to VM using password authentication
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    needs: build-and-push
    env:
      BACKEND_IMAGE: ${{ needs.build-and-push.outputs.backend_image }}
      FRONTEND_IMAGE: ${{ needs.build-and-push.outputs.frontend_image }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install sshpass
        run: sudo apt-get install -y sshpass

      - name: Create deployment directory on server
        env:
          SSHPASS: ${{ secrets.SERVER_PASSWORD }}
        run: |
          sshpass -e ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "mkdir -p /opt/job-platform/scripts"

      - name: Copy docker-compose file
        env:
          SSHPASS: ${{ secrets.SERVER_PASSWORD }}
        run: |
          sshpass -e scp -o StrictHostKeyChecking=no docker-compose.prod.yml ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/job-platform/

      - name: Copy deploy script
        env:
          SSHPASS: ${{ secrets.SERVER_PASSWORD }}
        run: |
          sshpass -e scp -o StrictHostKeyChecking=no scripts/deploy.sh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/job-platform/scripts/

      - name: Create environment file on server
        env:
          SSHPASS: ${{ secrets.SERVER_PASSWORD }}
        run: |
          sshpass -e ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} 'cat > /opt/job-platform/.env << EOF
          # Database
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_NAME=${{ secrets.DB_NAME }}
          DB_SSLMODE=disable
          # Redis
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          # Meilisearch
          MEILI_MASTER_KEY=${{ secrets.MEILI_MASTER_KEY }}
          # MinIO
          MINIO_ACCESS_KEY=${{ secrets.MINIO_ACCESS_KEY }}
          MINIO_SECRET_KEY=${{ secrets.MINIO_SECRET_KEY }}
          MINIO_BUCKET_NAME=resumes
          # JWT
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_ACCESS_EXPIRY=15m
          JWT_REFRESH_EXPIRY=168h
          # Security
          BCRYPT_COST=12
          # OAuth
          GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_REDIRECT_URL=${{ secrets.GOOGLE_REDIRECT_URL }}
          # Email
          EMAIL_PROVIDER=RESEND
          RESEND_API_KEY=${{ secrets.RESEND_API_KEY }}
          RESEND_FROM_EMAIL=${{ secrets.RESEND_FROM_EMAIL }}
          RESEND_FROM_NAME=JobPlatform
          # URLs
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          ADMIN_FRONTEND_URL=${{ secrets.ADMIN_FRONTEND_URL }}
          NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
          EMAIL_VERIFICATION_URL=${{ secrets.FRONTEND_URL }}/verify-email
          PASSWORD_RESET_URL=${{ secrets.FRONTEND_URL }}/reset-password
          # Docker Images
          BACKEND_IMAGE=${{ env.BACKEND_IMAGE }}:latest
          FRONTEND_IMAGE=${{ env.FRONTEND_IMAGE }}:latest
          EOF'
          # Remove leading spaces from .env file
          sshpass -e ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "sed -i 's/^[[:space:]]*//' /opt/job-platform/.env"

      - name: Deploy to server
        env:
          SSHPASS: ${{ secrets.SERVER_PASSWORD }}
        run: |
          sshpass -e ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            cd /opt/job-platform

            # Login to GitHub Container Registry
            echo "${{ secrets.GH_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Load environment variables
            set -a
            source .env
            set +a

            # Stop and remove old containers to avoid conflicts
            docker compose -f docker-compose.prod.yml down --remove-orphans 2>/dev/null || true
            docker rm -f $(docker ps -aq) 2>/dev/null || true

            # Pull latest images (use docker compose v2 only)
            docker compose -f docker-compose.prod.yml pull

            # Deploy services
            docker compose -f docker-compose.prod.yml up -d --remove-orphans

            # Wait for services to be ready
            echo "Waiting for services to start..."
            sleep 20

            # Health check
            if curl -sf http://localhost:8080/health; then
              echo "Backend health check passed!"
            else
              echo "Backend health check failed!"
              docker compose -f docker-compose.prod.yml logs backend
              exit 1
            fi

            # Cleanup old images
            docker image prune -f

            echo "Deployment successful!"
          ENDSSH

      - name: Deployment Summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend Image:** $BACKEND_IMAGE:latest" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend Image:** $FRONTEND_IMAGE:latest" >> $GITHUB_STEP_SUMMARY
          echo "- **Server:** ${{ secrets.SERVER_HOST }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** Deployed successfully" >> $GITHUB_STEP_SUMMARY
