name: Deploy to Production

on:
  push:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests (use with caution)'
        required: false
        default: false
        type: boolean
      force_backend:
        description: 'Force backend build'
        required: false
        default: false
        type: boolean
      force_frontend:
        description: 'Force frontend build'
        required: false
        default: false
        type: boolean
      force_infra:
        description: 'Force infra deploy'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io

jobs:
  # Detect what changed
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
      infra: ${{ steps.filter.outputs.infra }}
      backend_image: ${{ steps.set-images.outputs.backend_image }}
      frontend_image: ${{ steps.set-images.outputs.frontend_image }}
      short_sha: ${{ steps.set-images.outputs.short_sha }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check for changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            backend:
              - 'backend/**'
              - 'go.mod'
              - 'go.sum'
            frontend:
              - 'frontend/**'
            infra:
              - 'docker-compose.prod.yml'
              - 'nginx/**'
              - 'scripts/**'
              - '.github/workflows/deploy.yml'

      - name: Set image names
        id: set-images
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "backend_image=ghcr.io/${REPO_LOWER}/backend" >> $GITHUB_OUTPUT
          echo "frontend_image=ghcr.io/${REPO_LOWER}/frontend" >> $GITHUB_OUTPUT
          echo "short_sha=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT

      - name: Print detected changes
        run: |
          echo "Backend changed: ${{ steps.filter.outputs.backend }}"
          echo "Frontend changed: ${{ steps.filter.outputs.frontend }}"
          echo "Infra changed: ${{ steps.filter.outputs.infra }}"
          echo "Force backend: ${{ github.event.inputs.force_backend }}"
          echo "Force frontend: ${{ github.event.inputs.force_frontend }}"
          echo "Force infra: ${{ github.event.inputs.force_infra }}"

  # Test Backend (only if backend changed)
  test-backend:
    name: Test Backend
    runs-on: ubuntu-latest
    needs: changes
    if: |
      (needs.changes.outputs.backend == 'true' || github.event.inputs.force_backend == 'true') &&
      github.event.inputs.skip_tests != 'true'
    defaults:
      run:
        working-directory: backend

    services:
      postgres:
        image: postgres:17-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: jobdb_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7.4-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache-dependency-path: backend/go.sum

      - name: Download dependencies
        run: go mod download

      - name: Run tests
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: postgres
          DB_PASSWORD: postgres
          DB_NAME: jobdb_test
          DB_SSLMODE: disable
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          JWT_SECRET: test-jwt-secret-for-ci
          APP_ENV: test
        run: go test -v -race -coverprofile=coverage.out ./...

      - name: Build check
        run: go build -v ./...

  # Test Frontend (only if frontend changed)
  test-frontend:
    name: Test Frontend
    runs-on: ubuntu-latest
    needs: changes
    if: |
      (needs.changes.outputs.frontend == 'true' || github.event.inputs.force_frontend == 'true') &&
      github.event.inputs.skip_tests != 'true'
    defaults:
      run:
        working-directory: frontend

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'
          cache-dependency-path: frontend/yarn.lock

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Lint
        run: yarn lint

      - name: Type check
        run: yarn type-check

      - name: Build
        env:
          NEXT_PUBLIC_API_URL: http://localhost:8080/api/v1
        run: yarn build

  # Build Backend (only if backend changed)
  build-backend:
    name: Build Backend
    runs-on: ubuntu-latest
    needs: [changes, test-backend]
    if: |
      always() &&
      (needs.changes.outputs.backend == 'true' || github.event.inputs.force_backend == 'true') &&
      (needs.test-backend.result == 'success' || needs.test-backend.result == 'skipped')
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ needs.changes.outputs.backend_image }}
          tags: |
            type=sha,prefix=
            type=raw,value=latest
            type=raw,value=${{ github.run_number }}

      - name: Build and push Backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_VERSION=${{ needs.changes.outputs.short_sha }}
            BUILD_TIME=${{ github.event.head_commit.timestamp }}

  # Build Frontend (only if frontend changed)
  build-frontend:
    name: Build Frontend
    runs-on: ubuntu-latest
    needs: [changes, test-frontend]
    if: |
      always() &&
      (needs.changes.outputs.frontend == 'true' || github.event.inputs.force_frontend == 'true') &&
      (needs.test-frontend.result == 'success' || needs.test-frontend.result == 'skipped')
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ needs.changes.outputs.frontend_image }}
          tags: |
            type=sha,prefix=
            type=raw,value=latest
            type=raw,value=${{ github.run_number }}

      - name: Build and push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}

  # Deploy to production server
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    needs: [changes, build-backend, build-frontend]
    if: |
      always() &&
      (needs.build-backend.result == 'success' || needs.build-backend.result == 'skipped') &&
      (needs.build-frontend.result == 'success' || needs.build-frontend.result == 'skipped') &&
      (needs.changes.outputs.backend == 'true' || needs.changes.outputs.frontend == 'true' || needs.changes.outputs.infra == 'true' || github.event.inputs.force_backend == 'true' || github.event.inputs.force_frontend == 'true' || github.event.inputs.force_infra == 'true')
    environment: production
    env:
      BACKEND_IMAGE: ${{ needs.changes.outputs.backend_image }}
      FRONTEND_IMAGE: ${{ needs.changes.outputs.frontend_image }}
      SHORT_SHA: ${{ needs.changes.outputs.short_sha }}
      BACKEND_CHANGED: ${{ needs.changes.outputs.backend == 'true' || github.event.inputs.force_backend == 'true' }}
      FRONTEND_CHANGED: ${{ needs.changes.outputs.frontend == 'true' || github.event.inputs.force_frontend == 'true' }}
      INFRA_CHANGED: ${{ needs.changes.outputs.infra == 'true' || github.event.inputs.force_infra == 'true' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Create deployment directory on server
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
            "mkdir -p /opt/job-platform/scripts/postgres /opt/job-platform/nginx /opt/job-platform/backups"

      - name: Copy configuration files (infra changes)
        if: env.INFRA_CHANGED == 'true'
        run: |
          echo "Copying infrastructure files..."
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            docker-compose.prod.yml \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/job-platform/

          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            scripts/deploy.sh \
            scripts/backup-to-gdrive.sh \
            scripts/setup-gdrive-backup.sh \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/job-platform/scripts/

          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
            "chmod +x /opt/job-platform/scripts/*.sh"

          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            scripts/postgres/init-db.sh \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/job-platform/scripts/postgres/

          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            nginx/nginx.conf \
            nginx/.htpasswd \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/job-platform/nginx/ || true

      - name: Create environment file on server
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} 'cat > /opt/job-platform/.env << EOF
          # Database
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_NAME=${{ secrets.DB_NAME }}
          DB_SSLMODE=disable
          # Redis
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          # Meilisearch
          MEILI_MASTER_KEY=${{ secrets.MEILI_MASTER_KEY }}
          # MinIO
          MINIO_ACCESS_KEY=${{ secrets.MINIO_ACCESS_KEY }}
          MINIO_SECRET_KEY=${{ secrets.MINIO_SECRET_KEY }}
          MINIO_BUCKET_NAME=resumes
          # JWT
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_ACCESS_EXPIRY=15m
          JWT_REFRESH_EXPIRY=168h
          # Security
          BCRYPT_COST=12
          # OAuth
          GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_REDIRECT_URL=${{ secrets.GOOGLE_REDIRECT_URL }}
          # Email
          EMAIL_PROVIDER=RESEND
          RESEND_API_KEY=${{ secrets.RESEND_API_KEY }}
          RESEND_FROM_EMAIL=${{ secrets.RESEND_FROM_EMAIL }}
          RESEND_FROM_NAME=JobPlatform
          # AI Service (Anthropic)
          ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}
          # URLs
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          ADMIN_FRONTEND_URL=${{ secrets.ADMIN_FRONTEND_URL }}
          NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
          EMAIL_VERIFICATION_URL=${{ secrets.FRONTEND_URL }}/verify-email
          PASSWORD_RESET_URL=${{ secrets.FRONTEND_URL }}/reset-password
          # Docker Images
          BACKEND_IMAGE=${{ env.BACKEND_IMAGE }}:latest
          FRONTEND_IMAGE=${{ env.FRONTEND_IMAGE }}:latest
          # Deployment info
          DEPLOY_SHA=${{ env.SHORT_SHA }}
          DEPLOY_TIME=${{ github.event.head_commit.timestamp }}
          EOF'
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
            "sed -i 's/^[[:space:]]*//' /opt/job-platform/.env"

      - name: Deploy to server
        id: deploy
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            set -e
            cd /opt/job-platform

            # Login to GitHub Container Registry
            echo "${{ secrets.GH_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Load environment variables
            set -a
            source .env
            set +a

            BACKEND_CHANGED="${{ env.BACKEND_CHANGED }}"
            FRONTEND_CHANGED="${{ env.FRONTEND_CHANGED }}"
            INFRA_CHANGED="${{ env.INFRA_CHANGED }}"

            echo "======================================"
            echo "Smart Deployment - Only changed components"
            echo "Commit: ${DEPLOY_SHA}"
            echo "Backend changed: $BACKEND_CHANGED"
            echo "Frontend changed: $FRONTEND_CHANGED"
            echo "Infra changed: $INFRA_CHANGED"
            echo "======================================"

            # Save current image versions for potential rollback
            CURRENT_BACKEND=$(docker inspect job_backend --format='{{.Config.Image}}' 2>/dev/null || echo "none")
            CURRENT_FRONTEND=$(docker inspect job_frontend --format='{{.Config.Image}}' 2>/dev/null || echo "none")
            echo "$CURRENT_BACKEND" > /opt/job-platform/.rollback_backend
            echo "$CURRENT_FRONTEND" > /opt/job-platform/.rollback_frontend

            # Step 1: Pull only changed images
            echo "[1/5] Pulling changed images..."
            if [ "$BACKEND_CHANGED" = "true" ]; then
              echo "Pulling backend image..."
              docker compose -f docker-compose.prod.yml pull backend
            fi
            if [ "$FRONTEND_CHANGED" = "true" ]; then
              echo "Pulling frontend image..."
              docker compose -f docker-compose.prod.yml pull frontend
            fi

            # Step 2: Ensure infrastructure services are running
            echo "[2/5] Ensuring infrastructure services are running..."
            docker compose -f docker-compose.prod.yml up -d postgres redis meilisearch minio

            # Step 3: Wait for PostgreSQL to be ready
            echo "[3/5] Waiting for PostgreSQL to be ready..."
            # Find postgres container (handles both naming conventions)
            POSTGRES_CONTAINER=$(docker ps --format '{{.Names}}' | grep -E '(^job_postgres$|_job_postgres$|postgres)' | head -1)
            echo "Found PostgreSQL container: $POSTGRES_CONTAINER"

            MAX_RETRIES=30
            RETRY_COUNT=0
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if docker exec $POSTGRES_CONTAINER pg_isready -U ${DB_USER:-postgres} > /dev/null 2>&1; then
                echo "PostgreSQL is ready!"
                break
              fi
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "Waiting for PostgreSQL... ($RETRY_COUNT/$MAX_RETRIES)"
              sleep 2
            done

            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "ERROR: PostgreSQL failed to start!"
              docker ps -a
              exit 1
            fi

            # Ensure database exists
            DB_EXISTS=$(docker exec $POSTGRES_CONTAINER psql -U ${DB_USER:-postgres} -tAc "SELECT 1 FROM pg_database WHERE datname = '${DB_NAME:-jobdb}'" 2>/dev/null || echo "0")
            if [ "$DB_EXISTS" != "1" ]; then
              echo "Creating database ${DB_NAME:-jobdb}..."
              docker exec $POSTGRES_CONTAINER psql -U ${DB_USER:-postgres} -c "CREATE DATABASE \"${DB_NAME:-jobdb}\";"
            fi
            docker exec $POSTGRES_CONTAINER psql -U ${DB_USER:-postgres} -d ${DB_NAME:-jobdb} -c 'CREATE EXTENSION IF NOT EXISTS "uuid-ossp";' 2>/dev/null || true
            docker exec $POSTGRES_CONTAINER psql -U ${DB_USER:-postgres} -d ${DB_NAME:-jobdb} -c 'CREATE EXTENSION IF NOT EXISTS "pgcrypto";' 2>/dev/null || true

            # Step 4: Deploy only changed containers
            echo "[4/5] Deploying changed containers..."
            DEPLOY_START=$(date +%s)

            # Zero-downtime deployment function
            zero_downtime_deploy() {
              local SERVICE=$1
              local CONTAINER_NAME=$2
              local PORT=$3

              echo "Zero-downtime deploy for $SERVICE..."

              # Get current container ID
              OLD_CONTAINER=$(docker ps -q --filter "name=$CONTAINER_NAME" 2>/dev/null | head -1)

              # Pull the new image
              docker compose -f docker-compose.prod.yml pull $SERVICE

              # If no port conflict (backend/internal services), use recreate
              if [ -z "$PORT" ]; then
                docker compose -f docker-compose.prod.yml up -d --force-recreate --no-deps $SERVICE
              else
                # For services with exposed ports, we need to stop old first
                # But minimize downtime by having image ready
                docker rm -f $CONTAINER_NAME $(echo $CONTAINER_NAME | sed 's/job_//') 2>/dev/null || true
                docker compose -f docker-compose.prod.yml up -d --no-deps $SERVICE
              fi

              # Wait for new container to be healthy
              echo "Waiting for $SERVICE to be healthy..."
              for i in $(seq 1 30); do
                if docker compose -f docker-compose.prod.yml ps $SERVICE | grep -q "healthy"; then
                  echo "$SERVICE is healthy!"
                  return 0
                fi
                sleep 2
              done
              echo "Warning: $SERVICE health check timed out"
            }

            if [ "$BACKEND_CHANGED" = "true" ]; then
              # Backend doesn't have host port conflict, can do true zero-downtime
              zero_downtime_deploy "backend" "job_backend" ""
            fi

            if [ "$FRONTEND_CHANGED" = "true" ]; then
              # Frontend has port 3000 exposed, minimal downtime
              zero_downtime_deploy "frontend" "job_frontend" "3000"
            fi

            if [ "$INFRA_CHANGED" = "true" ]; then
              echo "Deploying infrastructure (nginx, netdata)..."

              # Check if SSL certificate exists for jobsworld.in
              if [ ! -f /etc/letsencrypt/live/jobsworld.in/fullchain.pem ]; then
                echo "SSL certificate not found, obtaining new certificate..."

                # Stop nginx to free port 80
                docker stop job_nginx 2>/dev/null || true

                # Install certbot if not installed
                if ! command -v certbot &> /dev/null; then
                  apt-get update && apt-get install -y certbot
                fi

                # Create certbot directory
                mkdir -p /var/www/certbot

                # Get SSL certificate
                certbot certonly --standalone --non-interactive --agree-tos \
                  --email admin@jobsworld.in \
                  -d jobsworld.in -d www.jobsworld.in || true

                echo "SSL certificate obtained!"
              else
                echo "SSL certificate already exists"
              fi

              # Create nginx conf.d directory
              mkdir -p /opt/job-platform/nginx/conf.d

              # Nginx has ports 80/443, minimal downtime
              zero_downtime_deploy "nginx" "job_nginx" "80"
              # Clean up any old netdata containers with prefixed names
              docker ps -a --format '{{.Names}}' | grep -E 'netdata' | xargs -r docker rm -f 2>/dev/null || true
              docker compose -f docker-compose.prod.yml up -d netdata
            fi

            # Wait for containers to start
            echo "Waiting for containers to initialize..."
            sleep 10

            # Step 5: Health checks
            echo "[5/5] Running health checks..."
            MAX_RETRIES=12
            RETRY_COUNT=0
            HEALTH_OK=false

            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if curl -sf http://localhost:8080/health > /dev/null 2>&1; then
                echo "Backend health check passed!"
                HEALTH_OK=true
                break
              fi
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "Health check attempt $RETRY_COUNT/$MAX_RETRIES..."
              sleep 5
            done

            if [ "$HEALTH_OK" = false ]; then
              echo "ERROR: Health check failed! Attempting rollback..."
              if [ -f /opt/job-platform/.rollback_backend ] && [ "$(cat /opt/job-platform/.rollback_backend)" != "none" ]; then
                ROLLBACK_BACKEND=$(cat /opt/job-platform/.rollback_backend)
                ROLLBACK_FRONTEND=$(cat /opt/job-platform/.rollback_frontend)
                docker pull "$ROLLBACK_BACKEND" || true
                docker pull "$ROLLBACK_FRONTEND" || true
                sed -i "s|BACKEND_IMAGE=.*|BACKEND_IMAGE=$ROLLBACK_BACKEND|" .env
                sed -i "s|FRONTEND_IMAGE=.*|FRONTEND_IMAGE=$ROLLBACK_FRONTEND|" .env
                source .env
                docker compose -f docker-compose.prod.yml up -d backend frontend
                echo "Rollback completed."
              fi
              docker compose -f docker-compose.prod.yml logs --tail=100 backend
              exit 1
            fi

            # Frontend health check
            if curl -sf http://localhost:3000 > /dev/null 2>&1; then
              echo "Frontend health check passed!"
            else
              echo "Frontend may still be starting..."
            fi

            # Cleanup
            docker image prune -f

            DEPLOY_END=$(date +%s)
            DEPLOY_DURATION=$((DEPLOY_END - DEPLOY_START))

            echo "======================================"
            echo "Deployment completed successfully!"
            echo "Duration: ${DEPLOY_DURATION}s"
            echo "======================================"
            docker compose -f docker-compose.prod.yml ps
          ENDSSH

      - name: Deployment Summary
        if: always()
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Changed | Action |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|---------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Backend | ${{ env.BACKEND_CHANGED }} | ${{ env.BACKEND_CHANGED == 'true' && 'Rebuilt & Deployed' || 'Skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend | ${{ env.FRONTEND_CHANGED }} | ${{ env.FRONTEND_CHANGED == 'true' && 'Rebuilt & Deployed' || 'Skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Infra | ${{ env.INFRA_CHANGED }} | ${{ env.INFRA_CHANGED == 'true' && 'Config Updated' || 'Skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | \`${{ env.SHORT_SHA }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | ${{ steps.deploy.outcome == 'success' && '✅ Success' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Triggered by** | @${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY

      - name: Notify on failure
        if: failure()
        run: |
          echo "::error::Deployment failed! Check the logs for details."
