name: Deploy to Production

on:
  push:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests (use with caution)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io

jobs:
  # Set lowercase repo name
  setup:
    name: Setup
    runs-on: ubuntu-latest
    outputs:
      backend_image: ${{ steps.set-images.outputs.backend_image }}
      frontend_image: ${{ steps.set-images.outputs.frontend_image }}
      short_sha: ${{ steps.set-images.outputs.short_sha }}
    steps:
      - name: Set lowercase image names
        id: set-images
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "backend_image=ghcr.io/${REPO_LOWER}/backend" >> $GITHUB_OUTPUT
          echo "frontend_image=ghcr.io/${REPO_LOWER}/frontend" >> $GITHUB_OUTPUT
          echo "short_sha=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT

  # Security scanning
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner (filesystem)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'

      - name: Check Go dependencies for vulnerabilities
        working-directory: backend
        run: |
          go install golang.org/x/vuln/cmd/govulncheck@latest
          govulncheck ./... || true

  # Run tests first
  test-backend:
    name: Test Backend
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.skip_tests != 'true' }}
    defaults:
      run:
        working-directory: backend

    services:
      postgres:
        image: postgres:17-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: jobdb_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7.4-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache-dependency-path: backend/go.sum

      - name: Download dependencies
        run: go mod download

      - name: Run tests
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: postgres
          DB_PASSWORD: postgres
          DB_NAME: jobdb_test
          DB_SSLMODE: disable
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          JWT_SECRET: test-jwt-secret-for-ci
          APP_ENV: test
        run: go test -v -race -coverprofile=coverage.out ./...

      - name: Build check
        run: go build -v ./...

  test-frontend:
    name: Test Frontend
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.skip_tests != 'true' }}
    defaults:
      run:
        working-directory: frontend

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'
          cache-dependency-path: frontend/yarn.lock

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Lint
        run: yarn lint

      - name: Type check
        run: yarn type-check

      - name: Build
        env:
          NEXT_PUBLIC_API_URL: http://localhost:8080/api/v1
        run: yarn build

  # Build and push Docker images
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: [setup, security-scan]
    if: |
      always() &&
      (needs.setup.result == 'success') &&
      (needs.security-scan.result == 'success' || needs.security-scan.result == 'skipped')
    permissions:
      contents: read
      packages: write
      security-events: write
    outputs:
      backend_image: ${{ needs.setup.outputs.backend_image }}
      frontend_image: ${{ needs.setup.outputs.frontend_image }}
      short_sha: ${{ needs.setup.outputs.short_sha }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ needs.setup.outputs.backend_image }}
          tags: |
            type=sha,prefix=
            type=raw,value=latest
            type=raw,value=${{ github.run_number }}

      - name: Build and push Backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_VERSION=${{ needs.setup.outputs.short_sha }}
            BUILD_TIME=${{ github.event.head_commit.timestamp }}

      - name: Extract metadata for Frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ needs.setup.outputs.frontend_image }}
          tags: |
            type=sha,prefix=
            type=raw,value=latest
            type=raw,value=${{ github.run_number }}

      - name: Build and push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}

      - name: Scan Backend image with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.setup.outputs.backend_image }}:latest
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'

  # Deploy to production server
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    needs: [setup, build-and-push, test-backend, test-frontend]
    if: |
      always() &&
      (needs.build-and-push.result == 'success') &&
      (needs.test-backend.result == 'success' || needs.test-backend.result == 'skipped') &&
      (needs.test-frontend.result == 'success' || needs.test-frontend.result == 'skipped')
    environment:
      name: production
      url: ${{ secrets.FRONTEND_URL }}
    env:
      BACKEND_IMAGE: ${{ needs.build-and-push.outputs.backend_image }}
      FRONTEND_IMAGE: ${{ needs.build-and-push.outputs.frontend_image }}
      SHORT_SHA: ${{ needs.build-and-push.outputs.short_sha }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Create deployment directory on server
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
            "mkdir -p /opt/job-platform/scripts/postgres /opt/job-platform/nginx /opt/job-platform/backups"

      - name: Copy configuration files
        run: |
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            docker-compose.prod.yml \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/job-platform/

          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            scripts/deploy.sh \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/job-platform/scripts/

          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            scripts/postgres/init-db.sh \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/job-platform/scripts/postgres/

          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            nginx/nginx.conf \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/job-platform/nginx/ || true

      - name: Create environment file on server
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} 'cat > /opt/job-platform/.env << EOF
          # Database
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_NAME=${{ secrets.DB_NAME }}
          DB_SSLMODE=disable
          # Redis
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          # Meilisearch
          MEILI_MASTER_KEY=${{ secrets.MEILI_MASTER_KEY }}
          # MinIO
          MINIO_ACCESS_KEY=${{ secrets.MINIO_ACCESS_KEY }}
          MINIO_SECRET_KEY=${{ secrets.MINIO_SECRET_KEY }}
          MINIO_BUCKET_NAME=resumes
          # JWT
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_ACCESS_EXPIRY=15m
          JWT_REFRESH_EXPIRY=168h
          # Security
          BCRYPT_COST=12
          # OAuth
          GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_REDIRECT_URL=${{ secrets.GOOGLE_REDIRECT_URL }}
          # Email
          EMAIL_PROVIDER=RESEND
          RESEND_API_KEY=${{ secrets.RESEND_API_KEY }}
          RESEND_FROM_EMAIL=${{ secrets.RESEND_FROM_EMAIL }}
          RESEND_FROM_NAME=JobPlatform
          # URLs
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          ADMIN_FRONTEND_URL=${{ secrets.ADMIN_FRONTEND_URL }}
          NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
          EMAIL_VERIFICATION_URL=${{ secrets.FRONTEND_URL }}/verify-email
          PASSWORD_RESET_URL=${{ secrets.FRONTEND_URL }}/reset-password
          # Docker Images
          BACKEND_IMAGE=${{ env.BACKEND_IMAGE }}:latest
          FRONTEND_IMAGE=${{ env.FRONTEND_IMAGE }}:latest
          # Deployment info
          DEPLOY_SHA=${{ env.SHORT_SHA }}
          DEPLOY_TIME=${{ github.event.head_commit.timestamp }}
          EOF'
          # Remove leading spaces from .env file
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
            "sed -i 's/^[[:space:]]*//' /opt/job-platform/.env"

      - name: Deploy to server
        id: deploy
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            set -e
            cd /opt/job-platform

            # Login to GitHub Container Registry
            echo "${{ secrets.GH_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Load environment variables
            set -a
            source .env
            set +a

            echo "======================================"
            echo "Starting Zero-Downtime Deployment"
            echo "Commit: ${DEPLOY_SHA}"
            echo "======================================"

            # Save current image versions for potential rollback
            CURRENT_BACKEND=$(docker inspect job_backend --format='{{.Config.Image}}' 2>/dev/null || echo "none")
            CURRENT_FRONTEND=$(docker inspect job_frontend --format='{{.Config.Image}}' 2>/dev/null || echo "none")
            echo "Current backend: $CURRENT_BACKEND"
            echo "Current frontend: $CURRENT_FRONTEND"
            echo "$CURRENT_BACKEND" > /opt/job-platform/.rollback_backend
            echo "$CURRENT_FRONTEND" > /opt/job-platform/.rollback_frontend

            # Step 1: Pull new images (while old containers are still running)
            echo "[1/7] Pulling latest images..."
            docker compose -f docker-compose.prod.yml pull backend frontend

            # Step 2: Ensure infrastructure services are running
            echo "[2/7] Ensuring infrastructure services are running..."
            docker compose -f docker-compose.prod.yml up -d postgres redis meilisearch minio

            # Step 3: Wait for PostgreSQL to be ready
            echo "[3/7] Waiting for PostgreSQL to be ready..."
            MAX_RETRIES=30
            RETRY_COUNT=0
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if docker exec job_postgres pg_isready -U ${DB_USER:-postgres} > /dev/null 2>&1; then
                echo "PostgreSQL is ready!"
                break
              fi
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "Waiting for PostgreSQL... ($RETRY_COUNT/$MAX_RETRIES)"
              sleep 2
            done

            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "ERROR: PostgreSQL failed to start!"
              exit 1
            fi

            # Step 4: Ensure database exists
            echo "[4/7] Ensuring database exists..."
            DB_EXISTS=$(docker exec job_postgres psql -U ${DB_USER:-postgres} -tAc "SELECT 1 FROM pg_database WHERE datname = '${DB_NAME:-jobdb}'" 2>/dev/null || echo "0")
            if [ "$DB_EXISTS" != "1" ]; then
              echo "Creating database ${DB_NAME:-jobdb}..."
              docker exec job_postgres psql -U ${DB_USER:-postgres} -c "CREATE DATABASE \"${DB_NAME:-jobdb}\";"
            else
              echo "Database ${DB_NAME:-jobdb} already exists."
            fi

            # Ensure UUID extension exists
            docker exec job_postgres psql -U ${DB_USER:-postgres} -d ${DB_NAME:-jobdb} -c 'CREATE EXTENSION IF NOT EXISTS "uuid-ossp";' 2>/dev/null || true
            docker exec job_postgres psql -U ${DB_USER:-postgres} -d ${DB_NAME:-jobdb} -c 'CREATE EXTENSION IF NOT EXISTS "pgcrypto";' 2>/dev/null || true
            echo "Database ready!"

            # Step 5: Record deployment start
            echo "[5/7] Recording deployment state..."
            DEPLOY_START=$(date +%s)

            # Step 6: Deploy new containers
            echo "[6/7] Deploying new application containers..."
            docker compose -f docker-compose.prod.yml up -d backend frontend

            # Wait for new containers to start
            echo "Waiting for new containers to initialize..."
            sleep 15

            # Step 7: Health check with rollback capability
            echo "[7/7] Running health checks..."
            MAX_RETRIES=12
            RETRY_COUNT=0
            HEALTH_OK=false

            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if curl -sf http://localhost:8080/health > /dev/null 2>&1; then
                echo "Backend health check passed!"
                HEALTH_OK=true
                break
              fi
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "Health check attempt $RETRY_COUNT/$MAX_RETRIES..."
              sleep 5
            done

            if [ "$HEALTH_OK" = false ]; then
              echo "ERROR: Health check failed! Attempting rollback..."

              # Rollback to previous version
              if [ -f /opt/job-platform/.rollback_backend ] && [ "$(cat /opt/job-platform/.rollback_backend)" != "none" ]; then
                echo "Rolling back to previous version..."
                ROLLBACK_BACKEND=$(cat /opt/job-platform/.rollback_backend)
                ROLLBACK_FRONTEND=$(cat /opt/job-platform/.rollback_frontend)

                docker pull "$ROLLBACK_BACKEND" || true
                docker pull "$ROLLBACK_FRONTEND" || true

                sed -i "s|BACKEND_IMAGE=.*|BACKEND_IMAGE=$ROLLBACK_BACKEND|" .env
                sed -i "s|FRONTEND_IMAGE=.*|FRONTEND_IMAGE=$ROLLBACK_FRONTEND|" .env

                source .env
                docker compose -f docker-compose.prod.yml up -d backend frontend

                echo "Rollback completed. Please investigate the failed deployment."
              fi

              echo "Showing backend logs for debugging:"
              docker compose -f docker-compose.prod.yml logs --tail=100 backend
              exit 1
            fi

            # Frontend health check
            if curl -sf http://localhost:3000 > /dev/null 2>&1; then
              echo "Frontend health check passed!"
            else
              echo "Frontend may still be starting (this is usually okay)..."
            fi

            # Cleanup old unused images
            echo "Cleaning up old images..."
            docker image prune -f

            # Calculate deployment time
            DEPLOY_END=$(date +%s)
            DEPLOY_DURATION=$((DEPLOY_END - DEPLOY_START))

            echo "======================================"
            echo "Deployment completed successfully!"
            echo "Duration: ${DEPLOY_DURATION}s"
            echo "======================================"

            # Show running containers
            echo ""
            echo "Running containers:"
            docker compose -f docker-compose.prod.yml ps
          ENDSSH

      - name: Deployment Summary
        if: always()
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | \`$SHORT_SHA\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Backend Image** | \`$BACKEND_IMAGE:latest\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Frontend Image** | \`$FRONTEND_IMAGE:latest\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Server** | \`${{ secrets.SERVER_HOST }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | ${{ steps.deploy.outcome == 'success' && '✅ Success' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Triggered by** | @${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Workflow Run** | [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |" >> $GITHUB_STEP_SUMMARY

      - name: Notify on failure
        if: failure()
        run: |
          echo "::error::Deployment failed! Check the logs for details."
          # Add webhook notification here if you have Slack/Discord
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"❌ Deployment failed for commit ${{ env.SHORT_SHA }}"}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}
